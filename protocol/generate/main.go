// Command generate reads the LSP 3.18 metaModel.json and outputs Go source files
// for the protocol/ package: types, enumerations, and method constants.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// --- Meta model JSON schema ---

type MetaModel struct {
	MetaData      MetaData       `json:"metaData"`
	Requests      []Request      `json:"requests"`
	Notifications []Notification `json:"notifications"`
	Structures    []Structure    `json:"structures"`
	Enumerations  []Enumeration  `json:"enumerations"`
	TypeAliases   []TypeAlias    `json:"typeAliases"`
}

type MetaData struct {
	Version string `json:"version"`
}

type Request struct {
	Method           string  `json:"method"`
	TypeName         string  `json:"typeName"`
	Result           *Type   `json:"result"`
	Params           *Type   `json:"params"`
	MessageDirection string  `json:"messageDirection"`
	Documentation    string  `json:"documentation"`
}

type Notification struct {
	Method           string `json:"method"`
	TypeName         string `json:"typeName"`
	Params           *Type  `json:"params"`
	MessageDirection string `json:"messageDirection"`
	Documentation    string `json:"documentation"`
}

type Structure struct {
	Name          string     `json:"name"`
	Properties    []Property `json:"properties"`
	Extends       []Type     `json:"extends"`
	Mixins        []Type     `json:"mixins"`
	Documentation string     `json:"documentation"`
}

type Property struct {
	Name          string `json:"name"`
	Type          Type   `json:"type"`
	Optional      bool   `json:"optional"`
	Documentation string `json:"documentation"`
}

type Type struct {
	Kind    string `json:"kind"`
	Name    string `json:"name"`
	Items   []Type `json:"items"`
	Element *Type  `json:"element"`
	Key     *Type  `json:"key"`
	Value   json.RawMessage `json:"value"`
}

type Enumeration struct {
	Name          string     `json:"name"`
	Type          Type       `json:"type"`
	Values        []EnumVal  `json:"values"`
	Documentation string     `json:"documentation"`
	SupportsCustomValues bool `json:"supportsCustomValues"`
}

type EnumVal struct {
	Name          string      `json:"name"`
	Value         interface{} `json:"value"`
	Documentation string      `json:"documentation"`
}

type TypeAlias struct {
	Name          string `json:"name"`
	Type          Type   `json:"type"`
	Documentation string `json:"documentation"`
}

// --- Code generation ---

var goKeywords = map[string]bool{
	"break": true, "case": true, "chan": true, "const": true, "continue": true,
	"default": true, "defer": true, "else": true, "fallthrough": true, "for": true,
	"func": true, "go": true, "goto": true, "if": true, "import": true,
	"interface": true, "map": true, "package": true, "range": true, "return": true,
	"select": true, "struct": true, "switch": true, "type": true, "var": true,
}

// structIndex maps structure names for resolving extends/mixins.
var structIndex map[string]*Structure

func main() {
	data, err := os.ReadFile("metaModel.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "reading metaModel.json: %v\n", err)
		os.Exit(1)
	}

	var model MetaModel
	if err := json.Unmarshal(data, &model); err != nil {
		fmt.Fprintf(os.Stderr, "parsing metaModel.json: %v\n", err)
		os.Exit(1)
	}

	structIndex = make(map[string]*Structure, len(model.Structures))
	for i := range model.Structures {
		structIndex[model.Structures[i].Name] = &model.Structures[i]
	}

	outDir := filepath.Join("..", "generated")
	os.MkdirAll(outDir, 0o755)

	if err := generateTypes(outDir, &model); err != nil {
		fmt.Fprintf(os.Stderr, "generating types: %v\n", err)
		os.Exit(1)
	}
	if err := generateAliases(outDir, &model); err != nil {
		fmt.Fprintf(os.Stderr, "generating aliases: %v\n", err)
		os.Exit(1)
	}
	if err := generateEnums(outDir, &model); err != nil {
		fmt.Fprintf(os.Stderr, "generating enums: %v\n", err)
		os.Exit(1)
	}
	if err := generateMethods(outDir, &model); err != nil {
		fmt.Fprintf(os.Stderr, "generating methods: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %d structures, %d enumerations, %d methods in %s\n",
		len(model.Structures), len(model.Enumerations),
		len(model.Requests)+len(model.Notifications), outDir)
}

// --- Type generation ---

func generateTypes(outDir string, model *MetaModel) error {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by gossip/protocol/generate. DO NOT EDIT.\n\n")
	buf.WriteString("package protocol\n\n")

	// Skip structures that start with underscore (internal helper types)
	// but flatten their properties into the referencing structure.
	for _, s := range model.Structures {
		if strings.HasPrefix(s.Name, "_") {
			continue
		}
		writeStruct(&buf, &s)
	}

	return writeFormatted(filepath.Join(outDir, "types_gen.go"), buf.Bytes())
}

func writeStruct(buf *bytes.Buffer, s *Structure) {
	if s.Documentation != "" {
		writeDocComment(buf, s.Name, s.Documentation)
	}
	buf.WriteString(fmt.Sprintf("type %s struct {\n", exportName(s.Name)))

	props := collectProperties(s)
	seen := map[string]bool{}
	for _, p := range props {
		goName := exportName(p.Name)
		if seen[goName] {
			continue
		}
		seen[goName] = true

		goType := resolveType(&p.Type)
		jsonTag := p.Name
		omit := ""
		if p.Optional {
			omit = ",omitempty"
			if !isPointerType(goType) && !isSliceOrMap(goType) {
				goType = "*" + goType
			}
		}
		if p.Documentation != "" {
			writeDocComment(buf, "", p.Documentation)
		}
		buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s%s\"`\n", goName, goType, jsonTag, omit))
	}
	buf.WriteString("}\n\n")
}

// collectProperties flattens extends and mixins into a single property list.
func collectProperties(s *Structure) []Property {
	var all []Property
	for _, ext := range s.Extends {
		if ext.Kind == "reference" {
			if base, ok := structIndex[ext.Name]; ok {
				all = append(all, collectProperties(base)...)
			}
		}
	}
	for _, mix := range s.Mixins {
		if mix.Kind == "reference" {
			if base, ok := structIndex[mix.Name]; ok {
				all = append(all, collectProperties(base)...)
			}
		}
	}
	all = append(all, s.Properties...)
	return all
}

func resolveType(t *Type) string {
	switch t.Kind {
	case "base":
		return baseType(t.Name)
	case "reference":
		if strings.HasPrefix(t.Name, "LSP") {
			return exportName(t.Name)
		}
		return exportName(t.Name)
	case "array":
		if t.Element != nil {
			return "[]" + resolveType(t.Element)
		}
		return "[]interface{}"
	case "map":
		keyType := "string"
		if t.Key != nil {
			keyType = resolveType(t.Key)
		}
		valType := "interface{}"
		if t.Value != nil {
			var vt Type
			if err := json.Unmarshal(t.Value, &vt); err == nil {
				valType = resolveType(&vt)
			}
		}
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	case "or":
		// Union types: if nullable (contains "null"), make it pointer to the non-null type.
		// If mixed types, use interface{}.
		nonNull := filterNullTypes(t.Items)
		if len(nonNull) == 1 {
			resolved := resolveType(&nonNull[0])
			return resolved
		}
		return "interface{}"
	case "stringLiteral":
		return "string"
	case "literal":
		return "interface{}"
	case "tuple":
		return "interface{}"
	default:
		return "interface{}"
	}
}

func filterNullTypes(items []Type) []Type {
	var result []Type
	for _, item := range items {
		if item.Kind == "base" && item.Name == "null" {
			continue
		}
		result = append(result, item)
	}
	return result
}

func baseType(name string) string {
	switch name {
	case "string", "DocumentUri", "URI":
		return "string"
	case "integer":
		return "int32"
	case "uinteger":
		return "uint32"
	case "decimal":
		return "float64"
	case "boolean":
		return "bool"
	case "null":
		return "interface{}"
	default:
		return "interface{}"
	}
}

func isPointerType(t string) bool {
	return strings.HasPrefix(t, "*")
}

func isSliceOrMap(t string) bool {
	return strings.HasPrefix(t, "[]") || strings.HasPrefix(t, "map[") || t == "interface{}"
}

// --- Type alias generation ---

func generateAliases(outDir string, model *MetaModel) error {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by gossip/protocol/generate. DO NOT EDIT.\n\n")
	buf.WriteString("package protocol\n\n")

	for _, ta := range model.TypeAliases {
		goName := exportName(ta.Name)
		goType := resolveType(&ta.Type)
		if ta.Documentation != "" {
			writeDocComment(&buf, goName, ta.Documentation)
		}
		buf.WriteString(fmt.Sprintf("type %s = %s\n\n", goName, goType))
	}

	return writeFormatted(filepath.Join(outDir, "aliases_gen.go"), buf.Bytes())
}

// --- Enum generation ---

func generateEnums(outDir string, model *MetaModel) error {
	buf := &bytes.Buffer{}
	buf.WriteString("// Code generated by gossip/protocol/generate. DO NOT EDIT.\n\n")
	buf.WriteString("package protocol\n\n")

	for _, e := range model.Enumerations {
		goName := exportName(e.Name)
		baseT := resolveType(&e.Type)

		if e.Documentation != "" {
			writeDocComment(buf, goName, e.Documentation)
		}
		buf.WriteString(fmt.Sprintf("type %s %s\n\n", goName, baseT))

		if len(e.Values) > 0 {
			buf.WriteString("const (\n")
			for _, v := range e.Values {
				constName := goName + exportName(v.Name)
				switch val := v.Value.(type) {
				case string:
					buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, goName, val))
				case float64:
					buf.WriteString(fmt.Sprintf("\t%s %s = %d\n", constName, goName, int(val)))
				default:
					buf.WriteString(fmt.Sprintf("\t%s %s = %v\n", constName, goName, val))
				}
			}
			buf.WriteString(")\n\n")
		}
	}

	return writeFormatted(filepath.Join(outDir, "enums_gen.go"), buf.Bytes())
}

// --- Method constant generation ---

func generateMethods(outDir string, model *MetaModel) error {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by gossip/protocol/generate. DO NOT EDIT.\n\n")
	buf.WriteString("package protocol\n\n")

	type entry struct {
		constName string
		method    string
		doc       string
	}
	var entries []entry

	for _, r := range model.Requests {
		name := methodToConst(r.Method)
		entries = append(entries, entry{name, r.Method, r.Documentation})
	}
	for _, n := range model.Notifications {
		name := methodToConst(n.Method)
		entries = append(entries, entry{name, n.Method, n.Documentation})
	}

	sort.Slice(entries, func(i, j int) bool { return entries[i].constName < entries[j].constName })

	buf.WriteString("// LSP method constants.\nconst (\n")
	for _, e := range entries {
		if e.doc != "" {
			lines := strings.Split(e.doc, "\n")
			for _, line := range lines[:1] {
				buf.WriteString(fmt.Sprintf("\t// %s\n", strings.TrimSpace(line)))
			}
		}
		buf.WriteString(fmt.Sprintf("\t%s = %q\n", e.constName, e.method))
	}
	buf.WriteString(")\n")

	return writeFormatted(filepath.Join(outDir, "methods_gen.go"), buf.Bytes())
}

func methodToConst(method string) string {
	method = strings.TrimPrefix(method, "$/")
	parts := strings.Split(method, "/")
	var result string
	for _, p := range parts {
		result += exportName(p)
	}
	return "Method" + result
}

// --- Helpers ---

func exportName(name string) string {
	if name == "" {
		return ""
	}
	// Remove leading underscores
	name = strings.TrimLeft(name, "_")
	if name == "" {
		return "X"
	}
	// Upper-case first rune
	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	result := string(runes)
	if goKeywords[strings.ToLower(result)] {
		result += "_"
	}
	return result
}

func writeDocComment(buf *bytes.Buffer, name, doc string) {
	lines := strings.Split(strings.TrimSpace(doc), "\n")
	maxLines := 3
	if len(lines) > maxLines {
		lines = lines[:maxLines]
	}
	for i, line := range lines {
		if i == 0 && name != "" {
			buf.WriteString(fmt.Sprintf("// %s: %s\n", name, strings.TrimSpace(line)))
		} else {
			buf.WriteString(fmt.Sprintf("// %s\n", strings.TrimSpace(line)))
		}
	}
}

func writeFormatted(path string, src []byte) error {
	formatted, err := format.Source(src)
	if err != nil {
		// Write unformatted so we can debug
		os.WriteFile(path+".err", src, 0o644)
		return fmt.Errorf("formatting %s: %w", path, err)
	}
	return os.WriteFile(path, formatted, 0o644)
}
